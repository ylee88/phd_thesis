\chapter{System-Free Picard Integral Formulation}\label{chap:sfpif}

Unlike the broad usage of SSP-RK in various discrete PDE solvers,
the developments of ADER mentioned above have been exclusively applied to FV and DG methods, but FD methods.
This is mainly because the fundamental principle of obtaining high-order accuracy
in the original ADER scheme relies on solving generalized (or high-order) Riemann problems,
which are the characteristic building blocks of FV and DG methods.

Recently, Christlieb et al.\ introduced a new high-order temporal scheme for FDM,
the so-called Picard integral formulation (PIF) method.~\cite{christlieb2015picard,seal2016explicit}
The PIF discretization is based on the constructions of high-order approximation
to the time-averaged fluxes over \( \left[ t^{n}, t^{n + 1} \right] \),
allowing high-order temporal accuracy in a single-step update.
Firstly introduced in~\cite{christlieb2015picard},
the PIF method demonstrated third-order temporally accurate numerical fluxes
by computing the coefficients of the time-Taylor expansion of the averaged fluxes
via LW/CK procedure which converts the high-order temporal derivatives terms into the spatial derivatives.

However, like many Lax-Wendroff type methods, the PIF method requires
finding analytic derivations for flux Jacobians and Hessians.
Although the Jacobian and the Hessian calculations can be easily obtained
with the aid of symbolic manipulators such as \texttt{SymPy}, \texttt{Mathematica}, or \texttt{Maple},
it still demands complicated coding/debugging efforts and ample memory consumption.
Furthermore, as the Jacobian/Hessian calculations highly depend on the
type of the governing system under consideration,
it is required to re-derive the Jacobian/Hessian terms analytically every time
we need to solve a new system, e.g., shallow water equations or magnetohydrodynamics (MHD) equations, to name a few.
In addition, the calculation complexities of the Jacobian-\textit{like} terms are drastically increasing
with the number of spatial dimensions and the order of accuracy.



\section{Picard Integral Formulation}\label{sec:pif}
Applying the Picard integral formulation (PIF), the governing equations of the conservative system~\cref{eq:gov} can be discretized
by taking a time average within a single time step \( \dt \) over an interval \( \left[ t^{n}, t^{n + 1} \right] \),
\begin{equation}\label{eq:pif_time_avg}
    \bU^{n + 1} = \bU^{n} - \dt \left( \partial_{x} \bF^{avg} + \partial_{y} \bG^{avg} + \partial_{z} \bH^{avg} \right),
\end{equation}
where \( \bF^{avg}, \bG^{avg}, \) and \( \bH^{avg} \) are the time-averaged fluxes in each direction,
\begin{equation}\label{eq:pif_avg_flux}
    \begin{split}
        \bF^{avg} (\bx) = \frac{1}{\dt} \int_{t^{n}}^{t^{n + 1}} \bF (\bU(\bx, t)) \mathop{dt}, \\
        \bG^{avg} (\bx) = \frac{1}{\dt} \int_{t^{n}}^{t^{n + 1}} \bG (\bU(\bx, t)) \mathop{dt}, \\
        \bH^{avg} (\bx) = \frac{1}{\dt} \int_{t^{n}}^{t^{n + 1}} \bH (\bU(\bx, t)) \mathop{dt}, \\
    \end{split}
\end{equation}
for \( \bx = (x, y, z) \in \mathbb{R}^{3} \).

The goal is to express the spatial derivatives of the time-averaged fluxes in~\cref{eq:pif_time_avg}
using highly approximated numerical fluxes \( \hat{\bff}, \hat{\bg}, \) and \( \hat{\bh} \)
at cell interfaces:
\begin{equation}\label{eq:pif_num_flux}
    \begin{split}
        \left. \partial_{x} \bF^{avg} \right|_{\bx = \bx_{ijk}} &=
            \frac{1}{\dx} \left( \hat{\bff}_{\iph, j, k} - \hat{\bff}_{\imh, j, k} \right) + \mathcal{O} (\dx^{p} + \dt^{q}), \\
        \left. \partial_{y} \bG^{avg} \right|_{\bx = \bx_{ijk}} &=
            \frac{1}{\dy} \left( \hat{\bg}_{i, \jph, k} - \hat{\bg}_{i, \jmh, k} \right) + \mathcal{O} (\dy^{p} + \dt^{q}), \\
        \left. \partial_{z} \bH^{avg} \right|_{\bx = \bx_{ijk}} &=
            \frac{1}{\dz} \left( \hat{\bh}_{i, j, \kph} - \hat{\bh}_{i, j, \kmh} \right) + \mathcal{O} (\dz^{p} + \dt^{q}), \\
    \end{split}
\end{equation}
where \( \bx_{ijk} = (x_{i}, y_{j}, z_{k}) \) is the discretization indices.

The above equation is almost analog to~\cref{eq:fdm_flux_deriv},
which is the conventional way to construct numerical fluxes for FDM through
the high-order reconstruction schemes (\cref{eq:fdm_recon}).
The only difference is to take time-averaged fluxes, \( \bF^{avg}, \bG^{avg}, \) and \( \bH^{avg} \)
as an input of the reconstruction scheme rather than taking pointwise fluxes.
Thus~\cref{eq:pif_num_flux} states that with highly approximated time-averaged fluxes,
the resulting numerical fluxes from the conventional reconstruction schemes will be high-order in time and space.

With PIF-numerical fluxes, the governing equation can be expressed in a fully discretized form as,
\begin{equation}\label{eq:pif_full_discrete}
    \begin{split}
        \bU^{n + 1}_{i,j,k} = \bU^{n}_{i,j,k} &- \frac{\dt}{\dx} \left( \hat{\bff}_{\iph,j,k} - \hat{\bff}_{\imh,j,k} \right) \\
                                              &- \frac{\dt}{\dy} \left( \hat{\bg}_{i, \jph, k} - \hat{\bg}_{i, \jmh, k} \right) \\
                                              &- \frac{\dt}{\dz} \left( \hat{\bh}_{i, j, \kph} - \hat{\bh}_{i, j, \kmh} \right),
    \end{split}
\end{equation}
which requires only a single update while attaining high-order accuracy both in time and space.

It is worth remarking that the derived governing form in~\cref{eq:pif_full_discrete} for PIF
is something in between those of FVM and FDM\@. It is different from that of FVM in that
it does not carry any spatial average but the temporal average.
It is also different from that of FDM in that it does involve the temporal average in the fluxes in~\cref{eq:pif_avg_flux},
to which the numerical fluxes \( \hat{\bff}, \hat{\bg}, \) and \( \hat{\bh} \) approximate.

The time-averaged fluxes
are obtained through the Taylor expansion of the pointwise
flux around \( t^{n} \).
In the \( q \)th-order PIF method,
the time-averaged \( x \)-directional flux \( \bF^{avg} \)
is approximated as,
\begin{equation}\label{eq:pif_flux_taylor}
    \begin{split}
        \bF^{avg} (\bx)
        &= \frac{1}{\dt} \int^{t^{n + 1}}_{t^n} \bF(\bx, t) \mathop{dt}\\
        &= \bF (\bx, t^{n})
            + \left. \frac{\Delta t}{2!} \partial_{t}^{(1)} \bF (\bx, t) \right|_{t = t^{n}}
            + \left. \frac{\Delta t^{2}}{3!} \partial_{t}^{(2)} \bF (\bx, t) \right|_{t = t^{n}}
            % + \left. \frac{\Delta t^{3}}{4!} \partial_{t}^{(3)} \bF (\bx, t) \right|_{t = t^{n}}
            + \cdots \\
        &= \sum\limits_{i=0}^{q-1}
            \left.\frac{\dt^{i}}{(i+1)!} \partial_{t}^{(i)} \bF (\bx, t) \right|_{t = t^{n}} + \mathcal{O}(\Delta t^{q}) \\
        &= \bF^{appx,q} (\bx, t^{n}) + \mathcal{O}(\Delta t^{q}).
    \end{split}
\end{equation}
The \textit{temporally} \( q \)th-order approximated fluxes \( \bF^{appx, q} \)
will be used
as the inputs of the \( p\)th-order reconstruction scheme \( \mathcal{R}(\cdot) \)
that is combined with a characteristic flux splitting method \( \mathcal{FS}(\cdot) \) 
to apply the \( p \)th-order \textit{spatial} approximation to
the numerical flux \( \hat{\bff} \) at cell interfaces,
\begin{equation}\label{eq:num-flx}
    \hat{\bff}_{i + \half, j, k} =
        \mathcal{R}\left(
            \mathcal{FS}\left(\bF^{appx, q}_{i-r, j}, \dots,
                \bF^{appx, q}_{i+r+1, j}
        \right)
    \right)
    + \mathcal{O}(\dx^{p}),
\end{equation}
where \( r \) represents the stencil radius
required for the \( p \)th-order reconstruction method, \( \mathcal{R}(\cdot) \).
The details of the high-order reconstruction methods, \( \mathcal{R}(\cdot) \), and
the flux-splitting methods, \( \mathcal{FS}(\cdot) \) are described in~\cref{chap:high_order_methods}.

Therefore, the primary objective of the PIF method is to approximate the time-averaged fluxes
in the desired order \( q \), i.e., obtaining \( \bF^{appx, q} \).
For instance, the fourth-order PIF method is characterized by
the fourth-order approximated time-averaged flux in the \( x \)-direction, \( \bF^{appx,4} \),
from the Taylor expansion of the pointwise flux around \( t^{n} \).
As expressed in~\cref{eq:pif_flux_taylor}, the fourth-order PIF method requires
\begin{equation}\label{eq:pif_flux_4order}
    \begin{split}
        \bF^{appx, 4} (\bx) = \bF (\bx, t^{n})
            &+ \left. \frac{\Delta t}{2!} \partial_{t}^{(1)} \bF (\bx, t) \right|_{t = t^{n}} \\
            &+ \left. \frac{\Delta t^{2}}{3!} \partial_{t}^{(2)} \bF (\bx, t) \right|_{t = t^{n}}
            + \left. \frac{\Delta t^{3}}{4!} \partial_{t}^{(3)} \bF (\bx, t) \right|_{t = t^{n}}.
    \end{split}
\end{equation}
The other \( y \)- and \( z \)-directional approximated fluxes,
\( \bG^{appx, 4} \) and \( \bH^{appx, 4} \),
are defined in similarly.
The only remaining task for the fouth-order PIF method (PIF4) is transforming all the
time derivatives in~\cref{eq:pif_flux_4order} to the corresponding spatial derivatives
via LW/CK procedures;
thereby we could express~\cref{eq:pif_flux_4order} in a fully explicit form.

For simplicity, the compact subscript notation of partial derivatives is adopted
in the following discussions.
The subscripts represent the partial derivatives,
and the temporal expression of \( t = t^{n} \) is omitted.
In the compact notation, \cref{eq:gov} can be rewritten as,
\begin{equation}\label{eq:pif_gov_compact_notation}
    \bU_{t} + \nabla \cdot \mathcal{F}(\bU) = \bU_{t} + \bF_{x} + \bG_{y} + \bH_{z} = 0.
\end{equation}

By applying the chain rule to \( \bF_{t} \),
the evolution equation of the \( x \)-flux, \( \bF \) can be obtained as,
\begin{equation}\label{eq:flux_eqn}
    \bF_{t} = \bF_{\bU} \bU_{t},
\end{equation}
where \( \bF_{\bU} \) is the \( x \)-directional flux Jacobian matrix.
The above equation can be combined with~\cref{eq:pif_gov_compact_notation},
resulting the explicit expression for \( \bF_{t} \) as,
\begin{equation}\label{eq:pif_Ft}
    \bF_{t} = - \bF_{\bU} \Div, \quad \text{where } \Div = \bF_{x} + \bG_{y} + \bH_{z}
\end{equation}
The higher-order time derivatives could be achieved by taking partial derivatives to~\cref{eq:pif_Ft} recursively.
As an example, the second-order term is written as
\begin{equation}\label{eq:pif_Ftt}
    \bF_{tt} = \bF_{\bU \bU} \cdot \Div \cdot \Div - \bF_{\bU} \cdot \Div_{t},
\end{equation}
where
\begin{equation}\label{eq:pif_divt}
    \begin{split}
        \Div_{t} =
            &-\bF_{\bU \bU} \cdot \bU_{x} \cdot \Div - \bF_{\bU} \cdot \Div_{x} \\
            &-\bG_{\bU \bU} \cdot \bU_{y} \cdot \Div - \bG_{\bU} \cdot \Div_{y} \\
            &-\bH_{\bU \bU} \cdot \bU_{z} \cdot \Div - \bH_{\bU} \cdot \Div_{z},
    \end{split}
\end{equation}
and \( \bF_{\bU\bU} \) is the \( x \)-directional flux Hessian tensor.
In Euler equations, the flux Hessians, \( \bF_{\bU\bU}, \bG_{\bU\bU}, \) and \( \bH_{\bU\bU} \)
are the symmetric, rank-3 tensors, so a dot product between the Hessian tensor and a vector
is to be understood as a tensor contraction.
Thus a double dot product between the Hessian tensor and two vectors,
i.e., \( \bF_{\bU \bU} \cdot (\;) \cdot (\;) \) yields a vector of the same dimension with \( \bU \).

Following the same procedure,
an explicit form of the third-order time derivative of the flux
can be obtained as,
\begin{equation}\label{eq:pif_Fttt}
    \bF_{ttt} = -\bF_{\bU \bU \bU} \cdot \Div \cdot \Div \cdot \Div
    + 3 \bF_{\bU \bU} \cdot \Div \cdot \Div_{t}
    - \bF_{\bU} \cdot \Div_{tt},
\end{equation}
where
\begin{equation}\label{eq:pif_divtt}
    \begin{split}
        \Div_{tt} = \quad & \bF_{\bU \bU \bU} \cdot \Div \cdot \bU_{x} \cdot \Div + 2 \bF_{\bU \bU} \cdot \Div \cdot \Div_{x} - \bF_{\bU \bU} \cdot \bU_{x} \cdot \Div_{t} - \bF_{\bU} \cdot \Div_{tx} \\
            + & \bG_{\bU \bU \bU} \cdot \Div \cdot \bU_{y} \cdot \Div + 2 \bG_{\bU \bU} \cdot \Div \cdot \Div_{y} - \bG_{\bU \bU} \cdot \bU_{y} \cdot \Div_{t} - \bG_{\bU} \cdot \Div_{ty} \\
            + & \bH_{\bU \bU \bU} \cdot \Div \cdot \bU_{z} \cdot \Div + 2 \bH_{\bU \bU} \cdot \Div \cdot \Div_{z} - \bH_{\bU \bU} \cdot \bU_{z} \cdot \Div_{t} - \bH_{\bU} \cdot \Div_{tz},
    \end{split}
\end{equation}
and
\begin{equation}\label{eq:pif_divtx}
    \begin{split}
        \Div_{tx} = \quad & \bF_{\bU \bU \bU} \cdot \bU_{x} \cdot \Div \cdot \bU_{x} - \bF_{\bU \bU} \cdot \bU_{xx} \cdot \Div
        -2\bF_{\bU \bU} \cdot \Div_{x} \cdot \bU_{x} - \bF_{\bU} \cdot \Div_{xx} \\
            - & \bG_{\bU \bU \bU} \cdot \bU_{x} \cdot \Div \cdot \bU_{y} - \bG_{\bU \bU} \cdot \bU_{xy} \cdot \Div - \bG_{\bU \bU} \cdot \Div_{x} \cdot \bU_{y} \\
            - & \bG_{\bU \bU} \cdot \bU_{x} \cdot \Div_{y} - \bG_{\bU} \cdot \Div_{xy} \\
            - & \bH_{\bU \bU \bU} \cdot \bU_{x} \cdot \Div \cdot \bU_{z} - \bH_{\bU \bU} \cdot \bU_{xz} \cdot \Div - \bH_{\bU \bU} \cdot \Div_{x} \cdot \bU_{z} \\
            - & \bH_{\bU \bU} \cdot \bU_{x} \cdot \Div_{z} - \bH_{\bU} \cdot \Div_{xz},
    \end{split}
\end{equation}
and similarly for \( \Div_{ty} \) and \( \Div_{tz} \).

Collecting~\crefrange{eq:pif_Ft}{eq:pif_divtx} the fourth-order approximation of the time-averaged \( x \)-flux,
\( \bF^{appx, 4} \) can be expressed in the explicit form, as the spatial derivatives
are readily approximated through the conventional central differencing schemes.
In this dissertation, the conventional five-point central differencing formulae are used:
\begin{equation}\label{eq:pif_central_dfdx}
    \left. \bF_{x} \right|_{\bx = \bx_{ijk}} = \frac{\bF_{i-2} - 8 \bF_{i-1} + 8 \bF_{i+1} - \bF_{i+2} }{12\dx} + \mathcal{O}(\dx^{4}),
\end{equation}
\begin{equation}\label{eq:pif_central_dfdxx}
    \left. \bF_{xx} \right|_{\bx = \bx_{ijk}} = \frac{-\bF_{i-2} + 16 \bF_{i-1} - 30 \bF_{i} + 16 \bF_{i+1} - \bF_{i+2} }{12\dx^{2}} + \mathcal{O}(\dx^{4}).
\end{equation}
For the cross derivatives,
\begin{equation}\label{eq:pif_central_dfdxy}
    \left. \bF_{xy} \right |_{\bx = \bx_{ijk}} =
    \frac{\bF_{i+1, j+1} - \bF_{i-1, j+1} - \bF_{i+1, j-1} + \bF_{i-1 j-1}}{4\dx\dy} + \mathcal{O}(\dx^{2}, \dy^{2}).
\end{equation}

The above five-points central differencing formulae can produce sufficiently accurate predictions
of spatial derivatives for the PIF method.
However, these conventional approaches cannot capture the shock discontinuities,
leading to unforeseen spurious oscillations
at strong shock profiles. (e.g., Sod shock problem)

One solution to this issue is to introduce WENO nonlinear weights in~\cref{eq:weno_nonlin_weights}
to the central differencing formula.
Alike the fifth-order WENO reconstruction scheme,
consider the three central differencing schemes approximating
the first-order derivatives at \( x = x_{i} \),
in each sub-stencil as,
\begin{equation}\label{eq:pif_wenodiff_subs}
    \begin{split}
        \bd_{1} & = \frac{1}{2 \Delta x} \left( \bF_{i - 2} - 4 \bF_{i - 1} + 3 \bF_{i} \right), \\
        \bd_{2} & = \frac{1}{2 \Delta x} \left( - \bF_{i - 1} + \bF_{i + 1} \right), \\
        \bd_{3} & = \frac{1}{2 \Delta x} \left( - 3 \bF_{i} + 4 \bF_{i + 1} - \bF_{i + 2} \right).
    \end{split}
\end{equation}
Then the goal is to make a convex combination with the nonlinear weights \( \omega_{m} \)
describing the first-order derivatives at \( x=x_{i} \):
\begin{equation}\label{eq:pif_wenodiff_convex}
    \left. \bF_{x} \right|_{x = x_{i}} \approx \omega_{1} \bd_{1} + \omega_{2} \bd_{2} + \omega_{3} \bd_{3}.
\end{equation}
In a smooth region, following the original context of WENO,
the nonlinear weights \( \omega_{m} \) are anticipated to be reduced
to the linear weights \( \gamma_{m} \) so that the convex combination represents
the approximation of \( \bF_{x} \) in a whole five-point stencil.
That is to say, the convex combination with the linear weights
should be equal to~\cref{eq:pif_central_dfdx},
\begin{equation}\label{eq:pif_wenodiff_linear_convex}
    \gamma_{1} \bd_{1} + \gamma_{2} \bd_{2} + \gamma_{3} \bd_{3} =
    \frac{1}{12 \Delta x} \left( \bF_{i - 2} - 8 \bF_{i - 1} + 8 \bF_{i + 1} - \bF_{i + 2} \right).
\end{equation}
Explicitly, the linear weights for the five-point WENO-\textit{like} central differencing
are given by,
\begin{equation}\label{eq:pif_wenodiff_linear_weights}
    \gamma_{1} = \frac{1}{6} \quad \gamma_{2} = \frac{4}{6} \quad \gamma_{3} = \frac{1}{6}.
\end{equation}
The nonlinear weights \( \omega_{m} \) are calculated in the same way
as the classical WENO-JS reconstruction method in~\cref{eq:weno_nonlin_weights},
with the same choice of the smoothness indicators, \( \beta_{m} \) in \cref{eq:weno_smoothness_ind}.

Although the fourth-order PIF method requires the second-order derivatives, \cref{eq:pif_central_dfdxx},
and cross derivatives, \cref{eq:pif_central_dfdxy}; however, using the WENO-\textit{like}
central differencing formula above only for the first-order derivative
effectively reduces the oscillations of the PIF method.
Needless to say, the WENO-\textit{like} central differencing~\cref{eq:pif_wenodiff_convex}
increases the overall computational loads of the PIF method.

In practical code implementation, it is worth to noting that reusing the flux divergence \( \Div \)
for calculating high-order spatial derivatives is more efficient than calculating them directly.
For example, \( \Div_{x} \) can be calculated as \( \texttt{dx}(\Div) \),
with the numerical spatial derivative function \( \texttt{dx}(\cdot) \),
rather than calculating as \( \Div_{x} = \bF_{xx} + \bG_{yx}+ \bH_{zx} \).
This approach requires an additional guard cell layer
(resulting in two more guard cells for the five-points derivatives).
However, the overall code performance is better than
evaluating high-order derivatives in each direction without affecting the accuracy of the scheme.

The PIF method is a very efficient numerical strategy to update the solution in FDM formulation.
Once the high-order time-averaged fluxes are determined, the solution can be updated
through a single step by following the exact same process for the conventional FDM spatial reconstruction.
Using the conventional spatial strategy of the FDM formulation,
the PIF method can be ``swapped'' readily with the SSP-RK scheme
in the existing simulation code for improving the code performance.

However, the direct analytic derivations for flux Jacobians, Hessians (and more)
remain as the implementation hurdle for the PIF method.
Unlike SSP-RK methods, the PIF method requires different code implementation
for a different system of equations only because of the Jacobian-\textit{like} terms.
(e.g., \( \bF_{\bU} \), \( \bF_{\bU\bU} \), \( \bF_{\bU\bU\bU}, \dots \))
This dissertation aims to tackle this problem,
making a different strategy to use the LW/CK procedure,
which does not require analytical derivations of Jacobian-\textit{like} terms.



\section{System-Free approach}\label{sec:original_sf}

This section aims to provide a new alternate formulation of computing
the multiplications of Jacobian-vector and Hessian-vector-vector terms in~\crefrange{eq:pif_Ft}{eq:pif_divtx}.
The new approach will replace the necessity for analytical derivations
of the Jacobian-\textit{like} terms in the original PIF method that is system-dependent,
with a new system-independent formulation, based on the so-called ``Jacobian-free'' method,
which is widely used for Newton-Krylov-type
iterative schemes~\cite{gear1983iterative,brown1990hybrid,knoll2004jacobian,knoll2011application}.

Suppose the Taylor expansion for the flux vector \( \bF \) at a small displacement from \( \bU \),
\begin{subequations}\label{eq:sf_FeV}
    \begin{align}
        \label{eq:sf_FeV_right}\bF ( \bU + \varepsilon \bV) =
        \bF(\bU) + \varepsilon \bF_{\bU} \cdot \bV +
        \frac{1}{2} \varepsilon^{2} \bF_{\bU\bU} \cdot \bV \cdot \bV + \mathcal{O}(\varepsilon^{3}), \\
        \label{eq:sf_FeV_left}\bF ( \bU - \varepsilon \bV) =
        \bF(\bU) - \varepsilon \bF_{\bU} \cdot \bV +
        \frac{1}{2} \varepsilon^{2} \bF_{\bU\bU} \cdot \bV \cdot \bV + \mathcal{O}(\varepsilon^{3}),
    \end{align}
\end{subequations}
where \( \bV \) is an arbitrary vector that has
the same number of components as \( \bU \), and \( \varepsilon \) is a
small scalar perturbation.
By subtracting \cref{eq:sf_FeV_left} from \cref{eq:sf_FeV_right},
we get an expression of a central differencing that is of second-order in $\varepsilon$,
\begin{equation}\label{eq:sf_jac_free}
    \bF_{\bU} \cdot \bV = \frac{1}{2\varepsilon}
    \bigg[ \bF(\bU + \varepsilon \bV) -\bF(\bU - \varepsilon \bV) \bigg]
    + \mathcal{O} ( \varepsilon^{2} ).
\end{equation}
Alternatively, the first-order forward differencing or the backward differencing can be used here.
However, the above second-order central differencing is used for this dissertation,
so that the order of accuracy of the entire system-free approach consistently scales with \( \mathcal{O}(\varepsilon^{2}) \),
given that the Hessian approximation described in the following is to be bounded by \( \mathcal{O}(\varepsilon^{2}) \).
With the system-free approximation of Jacobian, all the Jacobian-vector products in \crefrange{eq:pif_Ft}{eq:pif_divtx}
are to be replaced with the central differencing in \cref{eq:sf_jac_free}.

For the approximation for Hessians, it is imperative to classify
the types of the Hessian tensor contraction.
The first type is the Hessian tensor contracts with the same vector twice, e.g., \( \bF_{\bU\bU} \cdot \bV \cdot \bV \),
and the second type is the tensor contracts with
two different vectors, e.g., \( \bF_{\bU\bU} \cdot \bV \cdot \bW \).

For the first type, we use a Taylor expansion analogous to \cref{eq:sf_FeV}
to approximate the Hessian-vector-vector product with
a central differencing of order \( \mathcal{O}(\varepsilon^{2}) \),
\begin{equation}\label{eq:sf_hes_free_vv}
    \bF_{\bU \bU} \cdot \bV \cdot \bV = \frac{1}{\varepsilon^{2}}
    \bigg[ \bF(\bU + \varepsilon \bV) -2\bF(\bU) -\bF(\bU - \varepsilon \bV) \bigg]
    + \mathcal{O} ( \varepsilon^{2} ).
\end{equation}
Using a simple vector calculus,
the second type can be derived from the first type in \cref{eq:sf_hes_free_vv}
by exploring a symmetric property of the Hessians,
\begin{equation}\label{eq:sf_hes_free_vw}
        \bF_{\bU \bU} \cdot \bV \cdot \bW = \frac{1}{2}
    \bigg[ \bF_{\bU \bU} \cdot \left( \bV + \bW \right) \cdot \left( \bV + \bW \right) -
          \left( \bF_{\bU \bU} \cdot \bV \cdot \bV + \bF_{\bU \bU} \cdot \bW \cdot \bW \right) \bigg].
\end{equation}
The Hessian approximations derived here are now ready to be substituted
in \crefrange{eq:pif_Ftt}{eq:pif_divtx}.

Theoretically speaking, the system-free procedure in the above
can be applied to any arbitrary order of derivatives of the flux function \( \bF \)
with respect to the conservative variable \( \bU \). For instance,
the fourth-order PIF method~\cref{eq:pif_flux_4order}
requires the third-order derivative of \( \bF \), i.e., \( \bF_{\bU\bU\bU} \).
Following the same mathematical basis of \cref{eq:sf_jac_free,eq:sf_hes_free_vv},
the tensor contractions with the same vectors can be approximated as,
\begin{equation}\label{eq:sf_don_free_vvv}
    \begin{split}
        \bF_{\bU \bU \bU} \cdot \bV \cdot \bV \cdot \bV = \frac{1}{2 \varepsilon^{3}}
        \bigg[& -\bF(\bU - 2 \varepsilon \bV) + 2\bF(\bU - \varepsilon \bV) \\
              & - 2\bF(\bU + \varepsilon \bV)+ \bF(\bU + 2 \varepsilon \bV)
        \bigg] + \mathcal{O} ( \varepsilon^{2} ).
    \end{split}
\end{equation}
We can further extend the procedure to compute the contraction
with three different vectors, \( \bV, \bW \), and \( \bX \),
\begin{equation}\label{eq:sf_don_free_vwx}
    \begin{split}
        \bF_{\bU \bU \bU} \cdot \bV \cdot \bW \cdot \bX = \frac{1}{6} \bigg[
            &\bF_{\bU \bU \bU} \cdot \left( \bV + \bW + \bX \right) \cdot \left( \bV + \bW + \bX \right) \cdot \left( \bV + \bW + \bX \right) \\
            & -\bF_{\bU \bU \bU} \cdot \left( \bV + \bW \right) \cdot \left( \bV + \bW \right) \cdot \left( \bV + \bW \right) \\
            & -\bF_{\bU \bU \bU} \cdot \left( \bV + \bX \right) \cdot \left( \bV + \bX \right) \cdot \left( \bV + \bX \right) \\
            & -\bF_{\bU \bU \bU} \cdot \left( \bW + \bX \right) \cdot \left( \bW + \bX \right) \cdot \left( \bW + \bX \right) \\
            & + \bF_{\bU \bU \bU} \cdot \bV \cdot \bV \cdot \bV \\
            & + \bF_{\bU \bU \bU} \cdot \bW \cdot \bW \cdot \bW \\
            & + \bF_{\bU \bU \bU} \cdot \bX \cdot \bX \cdot \bX
        \bigg],
    \end{split}
\end{equation}
and only to see that the number of terms to be computed 
rapidly increases in high-order tensor contraction terms.




\subsection{The proper choices of \( \varepsilon \)}

In the above system-free approximations, the choice of \( \varepsilon \) has to be considered carefully
as it affects the solution accuracy and stability.
On one hand, \( \varepsilon \) is needed to be minimized to improve
the approximated solution accuracy,
the quality of which will scale as the truncation error of \( \mathcal{O}(\varepsilon^{2}) \).
On the other hand, if it is too small the solution would be contaminated
by the floating-point roundoff error which is bounded by
the machine accuracy \( \varepsilon_{\text{mach}} \)~\cite{knoll2004jacobian}.
Therefore, $\varepsilon$ is to be determined judiciously
to provide a good balance between the two types of error.

A recent study by An et al.~\cite{an2011finite}
presents an effective analysis of choosing
\( \varepsilon \) in the context of the Jacobian-free Newton-Krylov iterative framework.
The authors have shown how to compute an ideal value of
\( \varepsilon \) which minimizes the error of the
central differencing in the Jacobian-vector approximation.

The main idea in~\cite{an2011finite} is to find a good
balance between the truncation error \( \mathcal{O}(\varepsilon^{2}) \)
of each Jacobian-free approximation in~\cref{eq:sf_jac_free}
and Hessian-free approximation in~\cref{eq:sf_hes_free_vv},
and the intrinsic floating-point roundoff error $\delta\bF(\bU)$ when calculating
the target exact function value $\bF(\bU)$ with
an approximate value $\bF(\bU) + \delta\bF(\bU)$.
The perturbation $\delta\bF(\bU)$ may include any errors characterized
in computer arithmetic such as roundoff errors, and is assumed to be
bounded by the machine accuracy.

Let $\bF(\bU)$ be an exact function value of $\bF$ at $\bU$, and let
$\bF^{*}(\bU) = \bF(\bU) + \delta \bF(\bU)$ be
an approximation to $\bF(\bU)$,
where $\delta \bF(\bU)$ is a perturbation of
$\bF(\bU)$ that is potentially due from roundoff errors and truncation errors
and is assumed to be bounded by the machine accuracy, i.e.,
$|| \delta\bF(\bU) || \le \varepsilon_{\text{mach}}$.
The main idea is to choose an optimal \( \varepsilon \) value
for the Jacobian-free approximation~\cref{eq:sf_jac_free},
$\varepsilon_{\text{jac}}^{op}$, in such a way that
the error is minimized
when approximating $\bF_{\bU} \cdot \bV$ using
the central differencing approximation of $\bF^{*}(\bU)$
in \cref{eq:sf_jac_free}, i.e.,
\begin{equation}\label{eq:sf_epsilon_jac_free}
    \begin{split}
        \bF_{\bU} \cdot \bV &\approx \frac{1}{2 \sigma} \big[ \bF^{*}(\bU + \sigma \bV) - \bF^{*}(\bU - \sigma \bV) \big] \\
            & = \frac{1}{2 \sigma} \big[ \bF(\bU + \sigma \bV) + \delta \bF(\bU + \sigma \bV)
            -\bF(\bU - \sigma \bV)  - \delta \bF(\bU - \sigma \bV) \big].
    \end{split}
\end{equation}
For the sake of this analysis, we assume that the function
$\bF:\mathbb{R}^n \to \mathbb{R}^n$ is defined to be continuously differentiable sufficiently everywhere,
 $\bF \in C^k(\mathbb{R}^n)$.
We now define the error $E$ by the difference between the central differencing approximation 
in~\cref{eq:sf_epsilon_jac_free} and $\bF_{\bU} \cdot \bV$,
\begin{equation} \label{eq:sf_epsilon_jac_free_error}
    \begin{split}
        E &= \frac{1}{2 \sigma} \big[ \bF^{*}(\bU + \sigma \bV) - \bF^{*}(\bU - \sigma \bV) \big]
            - \bF_{\bU} \cdot \bV \\
          &= \frac{1}{2 \sigma} \big[ \bF(\bU + \sigma \bV) - \bF(\bU - \sigma \bV) \big] +
          \frac{1}{2 \sigma} \big[ \delta \bF(\bU + \sigma \bV) - \delta \bF(\bU - \sigma \bV) \big] -
            \bF_{\bU} \cdot \bV \\
        &= \frac{1}{2 \sigma} \left[
            2 \sigma \bF_{\bU} \cdot \bV +
            \sigma^{3} \int_{0}^{1} \left( 1 - t \right)^{2}  \bF^{(3)} (\bU + t \sigma \bV) \cdot \bV^{3} \mathop{dt}
        \right] \\
        &\qquad + \frac{1}{2 \sigma} \big[ \delta \bF(\bU + \sigma \bV) - \delta \bF(\bU - \sigma \bV) \big] -
            \bF_{\bU} \cdot \bV \\
        &= \mathcal{O}\biggl(\frac{\sigma^2}{2} + \frac{\varepsilon_{\text{mach}}}{2\sigma} \biggr),
    \end{split}
\end{equation}
where the Taylor series expansion around $\bU$ is used for each term
in which the remainders after the third power are given
as the integral form as below,
\begin{equation}\label{eq:sf_epsilon_jac_free_taylor}
    \begin{split}
        \bF(\bU + \sigma \bV) & = \bF(\bU) + \sigma \bF_{\bU} \cdot \bV + \frac{\sigma^{2}}{2} \pdd{\bF}{\bU} \cdot \bV \cdot \bV \\
                              & \qquad + \frac{\sigma^{3}}{2} \int_{0}^{1} \left( 1 - t \right)^{2} \bF^{(3)} (\bU + t \sigma \bV) \cdot \bV^{3} \mathop{dt}, \\
        \bF(\bU - \sigma \bV) & = \bF(\bU) - \sigma \bF_{\bU} \cdot \bV + \frac{\sigma^{2}}{2} \pdd{\bF}{\bU} \cdot \bV \cdot \bV \\
                              & \qquad - \frac{\sigma^{3}}{2} \int_{0}^{1} \left( 1 - t \right)^{2} \bF^{(3)} (\bU + t \sigma \bV) \cdot \bV^{3} \mathop{dt}. \\
    \end{split}
\end{equation}
The optimal choice of \( \varepsilon_{\text{jac}}^{op} \) is to be obtained
by considering the minimization problem of the leading error term in the
last line in~\cref{eq:sf_epsilon_jac_free_error},
\begin{equation}\label{eq:sf_epsilon_jac_optimal}
    \varepsilon^{op}_{\text{jac}} = \argmin_{\sigma > 0}
        \left( \frac{\sigma^{2}}{2} + \frac{\varepsilon_{\text{mach}}}{2 \sigma} \right) =
        {\left( \frac{\varepsilon_{\text{mach}}}{2} \right)}^{\frac{1}{3}} \approx \num{4.8062e-06},
\end{equation}
where \( \varepsilon_{\text{mach}} \sim \num{2.2204E-16} \) is used
assuming a double-precision in a typical 64-bit machine.

Following the similar procedures, the optimal epsilon value for
the Hessian-free approximation~\cref{eq:sf_hes_free_vv}, \( \varepsilon_{\text{hes}}^{op} \)
can be found as,
\begin{equation}\label{eq:sf_epsilon_hes_optimal}
    \varepsilon^{op}_{\text{hes}} = \argmin_{\sigma > 0}
        \left( \frac{\sigma^{2}}{3} + \frac{\varepsilon_{\text{mach}}}{\sigma^{2}} \right) =
        {\left( 3 \varepsilon_{\text{mach}} \right)}^{\frac{1}{4}} \approx \num{1.6065e-04}.
\end{equation}

However, direct use of \( \varepsilon^{op} \) as
the displacement step size in the central differencing schemes
in \cref{eq:sf_jac_free} and \cref{eq:sf_hes_free_vv}
is not a good idea for stability reasons.
%
Usually, the vector \( \bV \) in
\cref{eq:sf_jac_free} and \cref{eq:sf_hes_free_vv} could have an
enormous value in a strong shock region, so it is safer to use
a smaller step size to preserve the needed stability. To meet this,
the ideal value, \( \varepsilon^{op} \) should be normalized
by the magnitude of the vector \( \bV \).
%
There are several prescriptions available
in the Jacobian-free Newtonâ€“Krylov 
literatures~\cite{knoll2004jacobian, brown1990hybrid}
to help finalize the decision of choosing a proper value of \( \varepsilon \)
as a function of  \( \varepsilon^{op} \).
%
Nonetheless, as reported in~\cite{lee2021single},
a simple approach of
taking a square root of \( \varepsilon^{op} \)
with a simple normalization is sufficient to attain the desired accuracy and stability,
which is given as,
%
\begin{equation}\label{eq:sf_epsilon_norm}
    \overline{\varepsilon} = \frac{\sqrt{\varepsilon^{op}}}{\left\lVert \bV \right\rVert_{2}}.
\end{equation}

Lastly,
the \( \varepsilon \) estimation can be finalized
by taking the minimum value between $\overline{\varepsilon}$ and $\dt$,
%
\begin{equation}\label{eq:sf_epsilon_min_dt}
    \varepsilon = \min \left( \overline{\varepsilon}, \; \dt  \right),
\end{equation}
to prevent the division by zero case.


\section{Recursive System-Free approach}\label{sec:recursive_sf}

The original system-free (SF) approach presented in the previous section
provides good approximations of tensor contractions between Jacobian-\textit{like} terms and vectors.
However, the original SF method becomes less attractive for
any PIF method higher than third-order accuracy,
as it demands increasing complexity in code implementation,
which results in a significant loss in the overall performance of the code.
For example, \cref{eq:sf_don_free_vwx} requires 28 times flux function calls
for just getting a single tensor contraction, \( \bF_{\bU\bU\bU} \cdot \bV \cdot \bW \cdot \bX \).
It is worth noting that the major bottleneck of the original SF method
stems from \cref{eq:sf_hes_free_vw} and \cref{eq:sf_don_free_vwx}
that require to perform the Jacobian-\textit{like} approximations multiple times.

To avoid the additional modifications for the case of the tensor contractions with different vectors,
the improved version of the SF method was proposed in~\cite{lee2021recursive}.
This new, improved SF method, apply the Jacobian-free method recursively to construct the high-order Jacobian-\textit{like} terms.

The recursive SF method starts from defining a functional \( \mathcal{D}_{u} \)
that represents the Jacobian-free method denoted in~\cref{eq:sf_jac_free}:
\begin{equation}\label{eq:rsf_functional}
    \bF_{\bU} \cdot \bV \approx \mathcal{D}_{u} (\bF \scolon \bV) \coloneqq
    \frac{1}{2\varepsilon_{v}} \bigg[
        \bF(\bU + \varepsilon_{v} \bV) - \bF(\bU - \varepsilon_{v} \bV)
    \bigg],
\end{equation}
where \( \varepsilon_{v} \) is the appropriately calculated \( \varepsilon \)
corresponding to the vector \( \bV \)
by following the original system-free method~\cref{eq:sf_epsilon_norm},
\begin{equation}\label{eq:rsf_epsilon}
    \varepsilon_{v} = \min \left(\bar{\varepsilon}_{v}, \; \dt \right), \quad \text{where} \;
    \bar{\varepsilon}_{v} = \frac{\sqrt{\varepsilon^{op}}}{\left\lVert \bV \right\rVert_{2}}.
\end{equation}
The recursive SF method uses \( \varepsilon^{op} = \num{4.8062e-06} \)
that is the optimal \( \varepsilon \) value
for the second-order Jacobian-free approximation in the 64-bit machine
as it shown in \cref{eq:sf_epsilon_jac_optimal}.
This choice is also justifiable for the recursive scheme considered below,
where the functional \( \mathcal{D}_{u} \) itself is defined as the Jacobian-free method fundamentally.

By applying \( \mathcal{D}_{u} \) in the following successive fashion,
the tensor contractions between higher order derivatives for
the flux function \( \bF \) and arbitrary vectors.
For instance, the Hessian approximation becomes,
\begin{equation}\label{eq:rsf_hes_free}
    \begin{split}
        \bF_{\bU \bU} \cdot \bV \cdot \bW &\approx
        \mathcal{D}_{u} \Big( \mathcal{D}_{u} (\bF \scolon \bV) \scolon \bW \Big) \\
        &
        \begin{split}
            =\frac{1}{4 \varepsilon_{v} \varepsilon_{w}}
                \bigg[
                     &\bF(\bU + \varepsilon_{v} \bV + \varepsilon_{w} \bW)
                    -\bF(\bU - \varepsilon_{v} \bV + \varepsilon_{w} \bW)\\
                    -&\bF(\bU + \varepsilon_{v} \bV - \varepsilon_{w} \bW)
                    +\bF(\bU - \varepsilon_{v} \bV - \varepsilon_{w} \bW)
                \bigg].
        \end{split}
    \end{split}
\end{equation}
Again, following~\cref{eq:rsf_epsilon},
\( \varepsilon_{v} \) and \( \varepsilon_{w} \) are the optimal \( \varepsilon \) values
normalized by its corresponding vectors \( \bV \) and \( \bW \), respectively.

Note that the improved version of the Hessian-free method in \cref{eq:rsf_hes_free}
is applicable regardless the tensor contraction is
with two identical vectors (e.g., \( \bF_{\bU \bU} \cdot \bV \cdot \bV \))
or with two distinct vectors (e.g., \( \bF_{\bU \bU} \cdot \bV \cdot \bW \)),
hence it does not require separate formulations as in
\cref{eq:sf_hes_free_vw,eq:sf_don_free_vwx}.

The simplicity gain from the improved version of the system-free method
is further rewarded when
considering the higher-order derivatives of \( \bF \).
Following the equivalent strategy, the tensor contraction of
the third-order derivative of the flux function, \( \bF_{\bU \bU \bU} \)
with three distinct vectors, \( \bV, \bW \), and \( \bX \) is written compactly as,
\begin{equation}\label{eq:rsf_don_free}
    \begin{split}
        \bF_{\bU \bU \bU} & \cdot \bV \cdot \bW \cdot \bX \approx
        \mathcal{D}_{u} \Bigg( \mathcal{D}_{u} \Big( \mathcal{D}_{u} (\bF \scolon \bV) \scolon \bW \Big) \scolon \bX \Bigg) \\
        &
        \begin{split}
            =\frac{1}{8 \varepsilon_{v} \varepsilon_{w} \varepsilon_{x}}
            \bigg[
                &\bF(\bU + \varepsilon_{v} \bV + \varepsilon_{w} \bW + \varepsilon_{x} \bX)
                -\bF(\bU - \varepsilon_{v} \bV + \varepsilon_{w} \bW + \varepsilon_{x} \bX)\\
                -&\bF(\bU + \varepsilon_{v} \bV - \varepsilon_{w} \bW + \varepsilon_{x} \bX)
                +\bF(\bU - \varepsilon_{v} \bV - \varepsilon_{w} \bW + \varepsilon_{x} \bX)\\
                -&\bF(\bU + \varepsilon_{v} \bV + \varepsilon_{w} \bW - \varepsilon_{x} \bX)
                +\bF(\bU - \varepsilon_{v} \bV + \varepsilon_{w} \bW - \varepsilon_{x} \bX)\\
                +&\bF(\bU + \varepsilon_{v} \bV - \varepsilon_{w} \bW - \varepsilon_{x} \bX)
                -\bF(\bU - \varepsilon_{v} \bV - \varepsilon_{w} \bW - \varepsilon_{x} \bX)
            \bigg].
        \end{split}
    \end{split}
\end{equation}

Here, the performance between the recursive SF method and the original SF method
can be compared by the number of flux function calls.
For instance, considering the case of approximating \( \bF_{\bU\bU\bU} \cdot \bV \cdot \bW \cdot \bX \) term,
the original SF method requires 28 function calls.
On the other hand, the recursive SF method needs only eight evaluations.
This is a huge improvement in both performance and compactness. 

By utilizing~\crefrange{eq:rsf_functional}{eq:rsf_don_free},
all the tensor contractions needed in the fourth-order PIF method
in \crefrange{eq:pif_Ft}{eq:pif_divtx} can be approximated without
the analytical calculations of the Jacobian-\textit{like} terms.
Combining the recursive SF method, the PIF method can be implemented more efficiently,
allowing the system independence of the high-order scheme.
It should be noted that the recursive modifications of the SF method
presented in this section do not affect the solution's accuracy and stability
compared to the original SF method.

The fourth-order SF-PIF4 method can be summarized as the following stepwise fashion.
The discretization indices \( i,j,k \) and \( n \) are omitted for simplicity
in representing the conservative variables \( \bU^{n}_{ijk} \)
and the corresponding fluxes \( \mathcal{F}^{n}_{ijk} = (\bF^{n}_{ijk}, \bG^{n}_{ijk}, \bH^{n}_{ijk}) \).
\begin{enumerate}
    \item[] \textbf{Step 1:}
        Calculate \( \Div = \bF_{x} + \bG_{y} + \bH_{z} \) via the standard fourth-order accurate, 
        five-point central differencing scheme
        on every grid point and save them.
        These saved flux divergences will be used as inputs for the central differencing formulae
        in the following steps to get higher-order spatial derivatives.
        %
    \item[] \textbf{Step 2:}
        Apply the Jacobian approximation in \cref{eq:rsf_functional} in preparation 
        for \( \bF_{t} \) as expressed in \cref{eq:pif_Ft},
        and construct the second-order temporally averaged flux \( \bF^{appx,2} = \bF + \dt \bF_{t}/2 \).
        Apply the similar procedures to \( y- \) and \( z- \)directional fluxes to obtain
        \( \bG^{appx,2}\) and \( \bH^{appx,2}\).
        This finalizes the second-order temporal approximations of pointwise fluxes in all directions.
        %
    \item[] \textbf{Step 3:}
        Given the pointwise conservative variables \( \bU \) and
        the divergence of fluxes \( \Div \) from \textbf{Step 1},
        calculate \( \bU_{x}, \bU_{y}, \bU_{z}, \Div_{x}, \Div_{y}, \) and \( \Div_{z} \)
        via the same five-point central differencing operator in \textbf{Step 1}.
        They will be used as building blocks for constructing \( \bF_{tt}, \bG_{tt} \) and \( \bH_{tt} \)
        in the following steps.
        %
    \item[] \textbf{Step 4:}
        Apply the Jacobian and Hessian approximations in \cref{eq:rsf_functional,eq:rsf_hes_free} to
        the spatially approximated derivative quantities in \textbf{Step 3}
        in order to compute \( \Div_{t} \)
        by following the explicit expression in \cref{eq:pif_divt}.
        %
    \item[] \textbf{Step 5:}
        Apply the Jacobian approximation in \eqref{eq:rsf_functional}
        to \( \Div_{t} \) from \textbf{Step 4} and
        the Hessian approximation in \eqref{eq:rsf_hes_free}
        to \( \Div\) from  \textbf{Step 1} in order
        to get \( \bF_{tt} \) using \cref{eq:pif_Ftt};
        add the computed \( \bF_{tt} \)  to the results of \textbf{Step 2}
        to update the second-order temporal fluxes in \textbf{Step 2} 
        to the third-order temporally averaged flux,
        \( \bF^{appx,3} = \bF^{appx,2} + \dt^{2} \bF_{tt}/6 \).
        Perform the similar procedures in \( y- \) and \( z- \)directions to obtain
        \( \bG^{appx,3}\) and \( \bH^{appx,3}\).
        This finalizes the third-order temporal approximations of pointwise fluxes in all directions.
        %
    \item[] \textbf{Step 6:}
        Using the five-point central differencing, 
        compute the fourth-order accurate approximations 
        of the second derivatives and the mixed-derivatives
        of the conservative variables and the divergence of fluxes
        to obtain
        \( \bU_{xx}, \bU_{xy}, \bU_{yy}, \dots \) etc. and \( \Div_{xx}, \Div_{xy}, \Div_{yy}, \dots \) etc.
        %
    \item[] \textbf{Step 7:}
        Apply the tensor contractions of the first, second, and
        third-order flux derivatives in \cref{eq:rsf_functional,eq:rsf_hes_free,eq:rsf_don_free}
        to the quantities computed and stored from the previous steps in order to 
        calculate \( \Div_{tt} \) and \( \Div_{tx} \)
        by following the explicit relations in \cref{eq:pif_divtt,eq:pif_divtx} respectively.
        Also calculate \( \Div_{ty} \) and \( \Div_{tz} \) similarly.
        %
    \item[] \textbf{Step 8:}
        Next, perform the last set of tensor contractions
        in \cref{eq:rsf_functional,eq:rsf_hes_free,eq:rsf_don_free}
        to construct \( \bF_{ttt} \) as expressed in \cref{eq:pif_Fttt}.
        Add the resulting \( \bF_{ttt} \) to the result of \textbf{Step 5} to obtain the fourth-order
        temporally averaged flux,
        \( \bF^{appx,4} = \bF^{appx,3} + \dt^{3} \bF_{ttt}/24 \).
        Perform the similar procedures in \( y- \) and \( z- \)directions to obtain
        \( \bG^{appx,4}\) and \( \bH^{appx,4}\).
        This finalizes the fourth-order temporal approximations of pointwise fluxes in all directions.
        %
    \item[] \textbf{Step 9:}
        Proceed with the conventional FDM procedures for high-order spatial accuracy, viz.,
        apply a high-order reconstruction method with a characteristic flux-splitting strategy
        in Eq.~\eqref{eq:num-flx}
        to the results, \( \bF^{appx,4}\), \( \bG^{appx,4}\), and \( \bH^{appx,4}\),
        from \textbf{Step 8}. For example, taking WENO-JS (\cref{subsec:weno}) as a reconstruction method using
        \( \bF^{appx, 4} \) ensures a temporally fourth-order 
        and spatially fifth-order accurate approximation to the numerical flux,
        \( \hat{\bff} = \texttt{WENO-JS} \left ( \bF^{appx,4} \right) + \mathcal{O}(\dx^{5},\dt^{4}) \).
        Perform the similar procedures in \( y- \) and \( z- \)directions to obtain
        \( \hat{\bg}\) and \( \hat{\bh}\).
        %
    \item[] \textbf{Step 10:}
        Lastly, update the solution following \cref{eq:pif_full_discrete}.
\end{enumerate}





\section{System-Free PIF method with source term}\label{sec:sfpif_source}

Since the PIF method depends on the LW/CK procedure,
the PIF method must be modified accordingly when the governing equation has changed.
For instance, the non-homogeneous system of equations with a source term \( \bS(\bU) \),
the solution updating strategy for the original PIF method~\cref{eq:pif_time_avg}
should be modified with appropriately time-averaged source term.
Consider a conservative equations with a source term \( \bS(\bU) \),
\begin{equation}\label{eq:sf_source_gov}
    \bU_{t} + \nabla \cdot \mathcal{F}(\bU) = \bS(\bU).
\end{equation}
Taking time-averaging,
\begin{equation}\label{eq:sf_source_time_average}
    \bU^{n + 1} = \bU^{n} - \dt \left( \partial_{x} \bF^{avg} + \partial_{y} \bG^{avg} + \partial_{z} \bH^{avg} \right)
        + \dt \bS^{avg},
\end{equation}
where
\begin{equation}\label{eq:sf_source_time_taylor}
    \begin{split}
        \bS^{avg} (\bx)
        &= \frac{1}{\dt} \int^{t^{n + 1}}_{t^n} \bS(\bx, t) \mathop{dt}\\
        % &= \bS (\bx, t^{n})
        %     + \left. \frac{\Delta t}{2!} \partial_{t}^{(1)} \bS (\bx, t) \right|_{t = t^{n}}
        %     + \left. \frac{\Delta t^{2}}{3!} \partial_{t}^{(2)} \bS (\bx, t) \right|_{t = t^{n}}
        %     + \left. \frac{\Delta t^{3}}{4!} \partial_{t}^{(3)} \bS (\bx, t) \right|_{t = t^{n}}
        %     + \cdots \\
        &= \sum\limits_{i=0}^{q-1}
            \left.\frac{\dt^{i}}{(i+1)!} \partial_{t}^{(i)} \bS (\bx, t) \right|_{t = t^{n}} + \mathcal{O}(\Delta t^{q}) \\
        &= \bS^{appx,q} (\bx, t^{n}) + \mathcal{O}(\Delta t^{q}).
    \end{split}
\end{equation}
For the fourth-order PIF method, the fourth-order approximation of the time-averaged source term is needed,
\begin{equation}\label{eq:sf_source_4order}
    \begin{split}
        \bS^{appx, 4} (\bx) = \bS (\bx, t^{n})
            &+ \left. \frac{\Delta t}{2!} \partial_{t}^{(1)} \bS (\bx, t) \right|_{t = t^{n}}\\
            &+ \left. \frac{\Delta t^{2}}{3!} \partial_{t}^{(2)} \bS (\bx, t) \right|_{t = t^{n}}
            + \left. \frac{\Delta t^{3}}{4!} \partial_{t}^{(3)} \bS (\bx, t) \right|_{t = t^{n}}.
    \end{split}
\end{equation}

In order to modify the conventional PIF procedures
in a way that maintains the general mathematical structures
in~\cref{sec:pif},
% consider a modified flux divergence \( \Divs \) defined as,
a modified version of the flux divergence \( \Divs \) can be considered as,
\begin{equation}\label{eq:sf_source_divs}
    \Divs \coloneqq \Div - \bS.
\end{equation}
% Then, the time derivatives of the source term can be calculated through
% the LW/CK procedures as,
Then, the time derivatives of the source term have similar expressions
as the time derivatives of the flux function,
e.g., \( \bF_{t}, \bF_{tt}, \) and \( \bF_{ttt} \) in~\cref{eq:pif_Ft,eq:pif_Ftt,eq:pif_Fttt},
through the LW/CK procedures:
\begin{equation}\label{eq:sf_source_St}
    \bS_{t} = -\bS_{\bU} \Divs,
\end{equation}
\begin{equation}\label{eq:sf_source_Stt}
    \bS_{tt} = \bS_{\bU \bU} \cdot \Divs \cdot \Divs - \bS_{\bU} \cdot \Divs_{t},
\end{equation}
\begin{equation}\label{eq:sf_source_Sttt}
    \bS_{ttt} = -\bS_{\bU \bU \bU} \cdot \Divs \cdot \Divs \cdot \Divs
    + 3 \bS_{\bU \bU} \cdot \Divs \cdot \Divs_{t}
    - \bS_{\bU} \cdot \Divs_{tt}.
\end{equation}

The equation independence property of the system-free method
is rewarded in calculations of the source Jacobian \( \bS_{\bU} \) and Hessian \( \bS_{\bU\bU} \),
since the only required job is to change the flux function \( \bF(\cdot) \)
in~\cref{eq:rsf_functional,eq:rsf_hes_free} to the source function, \( \bS(\cdot) \).

The time derivatives of the modified flux divergence, \( \Divs_{t} \) and \( \Divs_{tt} \),
can be defined as linear combinations with the time derivatives of the conventional
flux divergence terms as,
\begin{equation}\label{eq:sf_source_divst}
    \begin{split}
        \Divs_{t} &= \Div_{t} - \bS_{t} \\
                  &= \Div_{t} + \bS_{\bU} \cdot \Divs,
    \end{split}
\end{equation}
and
\begin{equation}\label{eq:sf_source_divstt}
    \begin{split}
        \Divs_{tt} &= \Div_{tt} + \left( \bS_{\bU} \cdot \Divs \right)_{t} \\
                   &= \Div_{tt} - \bS_{\bU\bU} \cdot \Divs \cdot \Divs + \bS_{\bU} \cdot \Divs_{t},
    \end{split}
\end{equation}
where \( \Div_{t} \) and \( \Div_{tt} \) are defined in~\cref{eq:pif_divt,eq:pif_divtt}, respectively.


With a new governing equation, \cref{eq:sf_source_gov},
the high-order time derivatives of the flux functions, e.g., \( \bF_{t}, \bF_{tt}, \) and \( \bF_{ttt} \)
in \cref{eq:pif_flux_4order}
should be adjusted with the modified flux divergence, \( \Divs \).
The governing equation~\cref{eq:sf_source_gov} leads
the adjusted first-order time derivative of the flux as,
\begin{equation}\label{eq:sf_source_Ft}
    \bF_{t} = -\bF_{U} \Divs.
\end{equation}
Using the modified flux divergence, \( \Divs \), the adjusted time derivatives of the flux functions
maintain the similar mathematical structures in~\cref{eq:pif_Ft,eq:pif_Ftt,eq:pif_Fttt} as,
\begin{equation}\label{eq:sf_source_Ftt}
    \bF_{tt} = \bF_{\bU \bU} \cdot \Divs \cdot \Divs - \bF_{\bU} \cdot \Divs_{t},
\end{equation}
and
\begin{equation}\label{eq:sf_source_Fttt}
    \bF_{ttt} = -\bF_{\bU \bU \bU} \cdot \Divs \cdot \Divs \cdot \Divs
    + 3 \bF_{\bU \bU} \cdot \Divs \cdot \Divs_{t}
    - \bF_{\bU} \cdot \Divs_{tt},
\end{equation}
where \( \Divs_{t} \) and \( \Divs_{tt} \) are defined as in~\cref{eq:sf_source_divst,eq:sf_source_divstt} respectively.




\section{Conclusion}\label{sec:sf_conclusion}

The Picard integral formulation (PIF) method is one of the Lax-Wendroff class
high-order in temporal integration strategies for FDM discretization.
By virtue of a single-stage time integrator, the PIF method can perform
faster than the traditional multi-stage method.
Also, the PIF method does not depend on the spatial reconstruction scheme;
thus, it can be combined with any high-order spatial method in general.

However, as like other Lax-Wendroff type schemes,
the PIF method highly depends on the system of equations,
requiring analytical derivations for Jacobian-\textit{like} terms.
Although the symbolic manipulation tools can aid these calculations,
Jacobian-\textit{like} terms remain as a major implementation hurdle due to their perplexing structures.

The (original, non-recursive) system-free (SF) approach provides capability
to Lax-Wendroff type scheme to bypass all the analytical derivations of Jacobian-\textit{like} terms,
approximating tensor contractions between Jacobian-\textit{like} terms and arbitrary vectors.
The major advantage of SF method lies in ease of its code implementation for practical use.
By combining with PIF method, SF-PIF method can be applied to any system of equations
to furnish high-order in temporal accuracy in a single-step.
However, the increasing number of calculations needed for
higher order derivatives of the flux function \( \bF \) with respect to the conservative variables \( \bU \)
makes the SF method less attractive for higher than third-order PIF method.

The improved version, recursive SF approach is then introduced to minimize
the number of calculation needed for approximating the tensor contractions.
The recursive SF method introduced a functional representing the Jacobian-free method,
then the higher order derivative terms can be obtained by applying the functional recursively.
This feature allows to extend SF-PIF method to the fourth-order accuracy efficiently.

It is important to note that the SF method is neither designed particularly for the PIF method
nor any specific numerical methods in CFD.
Instead, it is solely intended for approximating the Jacobian-\textit{like} tensor contractions,
so the SF approach is applicable in otehr numerical algorithms
to enhance the calculation speed and implementation efficiency.
